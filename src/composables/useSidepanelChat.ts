import { onBeforeUnmount, onMounted, ref } from 'vue'
import { crawlUrlWithCache } from '~/services/webCrawlerService'
import { generateArticleAIResponse } from '~/services/aiService'
import { useChatState } from '~/composables/useChatState'

export function useSidepanelChat() {
  // State
  const currentUrl = ref('ƒêang t·∫£i...')
  const isLoading = ref(false)
  const hasError = ref(false)
  const errorMessage = ref('')
  const crawledContent = ref('')
  const selectedModel = ref('GPT-4.1')
  const availableModels = ['GPT-4.1', 'GPT-4o', 'Claude Sonnet 3.7', 'Claude Haiku']
  const chatMode = ref('Ask')
  const currentFileName = ref('Current Tab')

  const { messages, currentMessage, setCurrentMessage, addMessage, clearMessages, undoMessage, redoMessage } = useChatState()

  function getCurrentTabUrl() {
    chrome.tabs.query({ active: true, currentWindow: true }, (tabs: { url: string }[]) => {
      if (tabs && tabs[0]) {
        currentUrl.value = tabs[0].url || ''
        updateFileName()
      }
    })
  }

  function handleTabActivated() {
    getCurrentTabUrl()
  }

  function handleTabUpdated(_tabId: any, changeInfo: { url: string }, tab: { active: any }) {
    if (changeInfo.url && tab.active) {
      currentUrl.value = changeInfo.url
    }
  }

  onMounted(() => {
    getCurrentTabUrl()
    chrome.tabs.onActivated.addListener(handleTabActivated)
    chrome.tabs.onUpdated.addListener(handleTabUpdated)
  })

  onBeforeUnmount(() => {
    chrome.tabs.onActivated.removeListener(handleTabActivated)
    chrome.tabs.onUpdated.removeListener(handleTabUpdated)
  })

  async function sendMessage() {
    if (!currentMessage.value.trim() || isLoading.value)
      return

    const messageText = currentMessage.value.trim()
    addMessage({ role: 'user', content: messageText })
    setCurrentMessage('')
    isLoading.value = true
    hasError.value = false

    try {
      let articleContext = ''
      let articleAnalysis = ''

      if (currentUrl.value && currentUrl.value !== 'ƒêang t·∫£i...') {
        const results = await crawlUrlWithCache(currentUrl.value, {
          maxDepth: 1,
          maxPages: 1,
          extractArticleData: true,
          detectLanguage: true,
          extractKeywords: true,
        })
        if (results.length > 0) {
          const result = results[0]
          articleContext = result.content
          crawledContent.value = articleContext
          if (result.article) {
            const analysisParts = []
            analysisParts.push(`üì∞ B√†i vi·∫øt: "${result.article.title}"`)
            if (result.article.author)
              analysisParts.push(`‚úçÔ∏è T√°c gi·∫£: ${result.article.author}`)
            if (result.article.readingTime)
              analysisParts.push(`‚è±Ô∏è Th·ªùi gian ƒë·ªçc: ${result.article.readingTime} ph√∫t`)
            if (result.language) {
              const langName = result.language === 'vi' ? 'Ti·∫øng Vi·ªát' : 'Ti·∫øng Anh'
              analysisParts.push(`üåê Ng√¥n ng·ªØ: ${langName}`)
            }
            if (result.article.difficulty) {
              const difficultyMap = { easy: 'D·ªÖ ƒë·ªçc', medium: 'Trung b√¨nh', hard: 'Kh√≥ ƒë·ªçc' }
              analysisParts.push(`üìä ƒê·ªô kh√≥: ${difficultyMap[result.article.difficulty]}`)
            }
            if (result.keywords && result.keywords.length > 0) {
              analysisParts.push(`üè∑Ô∏è T·ª´ kh√≥a ch√≠nh: ${result.keywords.slice(0, 5).join(', ')}`)
            }
            articleAnalysis = analysisParts.join('\n')
          }
        }
      }
      const response = await generateCopilotResponse(messageText, articleContext, articleAnalysis)
      addMessage({ role: 'assistant', content: response })
    }
    catch (error) {
      hasError.value = true
      errorMessage.value = error instanceof Error ? error.message : 'L·ªói kh√¥ng x√°c ƒë·ªãnh'
      console.error('L·ªói khi g·ª≠i tin nh·∫Øn:', error)
    }
    finally {
      isLoading.value = false
    }
  }

  async function generateCopilotResponse(messageText: string, contextContent: string, articleAnalysis?: string): Promise<string> {
    if (messages.value.filter(m => m.role === 'assistant').length === 0) {
      return 'Xin ch√†o! T√¥i l√† GitHub Copilot.\nB·∫°n c·∫ßn h·ªó tr·ª£ g√¨ v·ªÅ l·∫≠p tr√¨nh ho·∫∑c d·ª± √°n c·ªßa m√¨nh?'
    }
    const isArticleSuggestion = detectArticleSuggestion(messageText)
    if (isArticleSuggestion && contextContent) {
      try {
        const prompt = createArticlePrompt(messageText, contextContent, currentUrl.value)
        const result = await generateArticleAIResponse({
          messages: [
            { role: 'system', content: 'You are GitHub Copilot, a helpful AI assistant that analyzes articles and provides insightful responses. Respond in Vietnamese and be thorough but concise. Use emojis and proper formatting to make responses engaging.' },
            { role: 'user', content: prompt },
          ],
          model: 'openai',
        })
        if (result.success && result.data) {
          return result.data.content
        }
        else {
          throw new Error(result.error || 'Failed to analyze article')
        }
      }
      catch (error) {
        console.error('Error calling Pollinations AI:', error)
        return `Xin l·ªói, t√¥i g·∫∑p l·ªói khi ph√¢n t√≠ch b√†i vi·∫øt: ${error instanceof Error ? error.message : 'Unknown error'}`
      }
    }
    let response = `T√¥i hi·ªÉu b·∫°n ƒëang h·ªèi v·ªÅ "${messageText}".`
    if (articleAnalysis) {
      response += `\n\nüìã **Ph√¢n t√≠ch b√†i vi·∫øt hi·ªán t·∫°i:**\n${articleAnalysis}`
    }
    if (contextContent) {
      response += `\n\nüìñ **D·ª±a tr√™n n·ªôi dung b√†i vi·∫øt**, t√¥i c√≥ th·ªÉ gi√∫p b·∫°n:`
      response += `\n‚Ä¢ Gi·∫£i th√≠ch c√°c thu·∫≠t ng·ªØ kh√≥ hi·ªÉu`
      response += `\n‚Ä¢ T√≥m t·∫Øt n·ªôi dung ch√≠nh`
      response += `\n‚Ä¢ Tr·∫£ l·ªùi c√¢u h·ªèi v·ªÅ b√†i vi·∫øt`
      response += `\n‚Ä¢ Ph√¢n t√≠ch quan ƒëi·ªÉm c·ªßa t√°c gi·∫£`
    }
    response += `\n\nB·∫°n c√≥ th·ªÉ h·ªèi t√¥i b·∫•t k·ª≥ ƒëi·ªÅu g√¨ v·ªÅ b√†i vi·∫øt n√†y!`
    return response
  }

  function detectArticleSuggestion(messageText: string): boolean {
    const suggestionKeywords = [
      'ask about this article',
      'summarize this article',
      'explain this article',
      'main takeaways',
      'generate questions about this article',
      'related topics should i explore',
      'provide a critical analysis',
      't√≥m t·∫Øt b√†i vi·∫øt',
      'gi·∫£i th√≠ch b√†i vi·∫øt',
      'ph√¢n t√≠ch b√†i vi·∫øt',
    ]
    const lowerText = messageText.toLowerCase()
    return suggestionKeywords.some(keyword => lowerText.includes(keyword))
  }

  function createArticlePrompt(messageText: string, content: string, url: string): string {
    const lowerText = messageText.toLowerCase()
    let taskDescription = ''
    if (lowerText.includes('summarize') || lowerText.includes('t√≥m t·∫Øt')) {
      taskDescription = 'summarize this article in a clear and concise way'
    }
    else if (lowerText.includes('explain') || lowerText.includes('gi·∫£i th√≠ch')) {
      taskDescription = 'explain this article in simple terms that anyone can understand'
    }
    else if (lowerText.includes('takeaways') || lowerText.includes('ƒëi·ªÉm ch√≠nh')) {
      taskDescription = 'identify the main takeaways and key points from this article'
    }
    else if (lowerText.includes('questions') || lowerText.includes('c√¢u h·ªèi')) {
      taskDescription = 'generate thoughtful questions about this article to help readers think deeper'
    }
    else if (lowerText.includes('related topics') || lowerText.includes('ch·ªß ƒë·ªÅ li√™n quan')) {
      taskDescription = 'suggest related topics and areas for further exploration based on this article'
    }
    else if (lowerText.includes('critical analysis') || lowerText.includes('ph√¢n t√≠ch ph√™ b√¨nh')) {
      taskDescription = 'provide a critical analysis of this article, including strengths, weaknesses, and different perspectives'
    }
    else if (lowerText.includes('ask about this article')) {
      taskDescription = 'provide an overview of what you can help with regarding this article and offer suggestions for different types of analysis'
    }
    else {
      taskDescription = 'help with the following request about this article'
    }
    return `\nBased on the following article, please ${taskDescription}.\n\nArticle URL: ${url}\nArticle Content:\n${content}\n\nUser Request: ${messageText}\n\nPlease provide a helpful and comprehensive response in Vietnamese. Use proper formatting with bullet points, emojis, and clear structure to make your response engaging and easy to read.`
  }

  function handleKeyPress(event: KeyboardEvent) {
    if (event.key === 'Enter' && !event.shiftKey) {
      event.preventDefault()
      sendMessage()
    }
  }

  function updateFileName() {
    try {
      if (currentUrl.value && currentUrl.value !== 'ƒêang t·∫£i...') {
        const url = new URL(currentUrl.value)
        currentFileName.value = url.pathname.split('/').pop() || url.hostname || 'Current Tab'
      }
    }
    catch {
      currentFileName.value = 'Current Tab'
    }
  }

  return {
    // State
    currentUrl,
    isLoading,
    hasError,
    errorMessage,
    crawledContent,
    messages,
    currentMessage,
    selectedModel,
    availableModels,
    chatMode,
    currentFileName,
    // Methods
    sendMessage,
    generateCopilotResponse,
    handleKeyPress,
    addMessage,
    updateFileName,
    clearMessages,
    undoMessage,
    redoMessage,
  }
}
